//Making a game of Checkers
//Imports
import java.io.FileWriter;
import java.io.File;
import java.io.FileReader;
import java.io.BufferedWriter;
import java.io.BufferedReader;
import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Control;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SkinBase;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Ellipse;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.transform.Translate;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.stage.Modality;
import javafx.stage.Stage;

// class defnition for reversi game
public class Checkers extends Application {
	// overridden init method
	public void init() {
		
		 vb_layout = new VBox();
		 ch_menubar = new MenuBar();
		 menu_file = new Menu("File");
		
		 hb_layout = new HBox();
         hb_layout.setSpacing(40.0);

		
		 tf_playername1 = new TextField();
		 lbl_playerscore1 = new Label("Player score: ");
		 
		 lbl_turn = new Label("Playing: ");
		
		 tf_playername2 = new TextField();
		 lbl_playerscore2 = new Label("Player score: ");
		
		 btn_draw = new Button("Draw Game");
		
		sp_mainlayout = new StackPane();  //Initialise rc_reversi and add it to mainlayout
		rc_checkers = new CheckersControl();
		ch_menubar.getMenus().addAll(menu_file);
		sp_mainlayout.getChildren().addAll(rc_checkers);
		
		hb_layout.getChildren().addAll(tf_playername1, lbl_playerscore1,lbl_turn, tf_playername2, lbl_playerscore2, btn_draw);
		vb_layout.getChildren().addAll(ch_menubar, hb_layout, sp_mainlayout);
		
		VBox.setVgrow(sp_mainlayout, Priority.ALWAYS); 
		
		 mi_new = new MenuItem("New Game");
		 mi_save = new MenuItem("Save Game");
		 mi_load = new MenuItem("Load Game");
		 mi_quit = new MenuItem("Quit Game"); 
		 menu_file.getItems().addAll(mi_new, mi_save, mi_load, mi_quit);
		
		 mi_new.setOnAction(new EventHandler<ActionEvent>() {
				
				// overridden method to handle an event for this menu item
			@Override
			public void handle(ActionEvent event) {
				rc_checkers.resetGame();
				 System.out.println("works reset");
			}
		});
				 
				
		mi_save.setOnAction(new EventHandler<ActionEvent>() {
				
				// overridden method to handle an event for this menu item
			@Override
			public void handle(ActionEvent event) {
				rc_checkers.saveGame();
			}
		});
				 
				
		mi_load.setOnAction(new EventHandler<ActionEvent>() {
				
			// overridden method to handle an event for this menu item
			@Override
			public void handle(ActionEvent event) {
				rc_checkers.loadGame();
			}
		});
				 
				
		 mi_quit.setOnAction(new EventHandler<ActionEvent>() {
				
			// overridden method to handle an event for this menu item
			@Override
			public void handle(ActionEvent event) {
				 stop();
				 Platform.exit();
			}
		});


		btn_draw.setOnAction(new EventHandler<ActionEvent>() {

		// overridden method to handle an event for this menu item
		@Override
		public void handle(ActionEvent event) {
		
		                final Stage dialogStage = new Stage();
		                dialogStage.initModality(Modality.APPLICATION_MODAL);
		                dialogStage.setTitle("Draw Game?");

		                Label drawLabel = new Label("Do both Players agree to draw the game?");
		                drawLabel.setAlignment(Pos.BASELINE_CENTER);

		                Button yesBtn = new Button("Yes");
		                yesBtn.setOnAction(new EventHandler<ActionEvent>() {

		                    @Override
		                    public void handle(ActionEvent arg0) {
		                        
		                    	stop();
		                        dialogStage.close();
		                    }
		                });
		                Button noBtn = new Button("No");

		                noBtn.setOnAction(new EventHandler<ActionEvent>() {

		                    @Override
		                    public void handle(ActionEvent arg0) {
		                        dialogStage.close();

		                    }
		                });
			
		                HBox hBox = new HBox();
		                hBox.setAlignment(Pos.BASELINE_CENTER);
		                hBox.setSpacing(40.0);
		                hBox.getChildren().addAll(yesBtn, noBtn);

		                VBox vBox = new VBox();
		                vBox.setSpacing(40.0);
		                vBox.getChildren().addAll(drawLabel, hBox);

		                dialogStage.setScene(new Scene(vBox));
		                dialogStage.show();
		}
		});
		
		
		if(rc_checkers.in_play() == true){
			lbl_playerscore1.setText("Player Score: " + rc_checkers.score1());
			lbl_playerscore2.setText("Player Score: " + rc_checkers.score2());
		
			if(rc_checkers.current_player() == 1){
				lbl_turn.setText("Playing: " + tf_playername1.getText());
			}
			else if(rc_checkers.current_player() == 2){
				lbl_turn.setText("Playing: " + tf_playername2.getText());
			}
		}	
	}
	
	// overridden start method
	public void start(Stage primaryStage) {
		//Set title and scene
	primaryStage.setTitle("Checkers");
		primaryStage.setScene(new Scene(vb_layout, 800, 800));

		primaryStage.show();
	}
	
	// overridden stop method
	public void stop() {
		
}
	
	// entry point into our program for launching our javafx applicaton
	public static void main(String[] args) {
		launch(args);

	}

	// private fields for a stack pane and a checkers control
	private StackPane sp_mainlayout;
	private CheckersControl rc_checkers;
	private VBox vb_layout;
	private HBox hb_layout;
	private TextField tf_playername1, tf_playername2;
	private Label lbl_turn, lbl_playerscore1, lbl_playerscore2;
	private Button btn_draw;
	
	private MenuBar ch_menubar;
	private Menu menu_file;
	private MenuItem mi_new, mi_save, mi_load, mi_quit;
}

// class definition for a custom checkers control
class CheckersControl extends Control {
	// constructor for the class
	
	public boolean in_play() {
		return c_board.in_play();
	}
	
	public int current_player() {
		return c_board.current_player();
	}
	public int score1() {
		return c_board.score1();
	}
	public int score2() {
		return	c_board.score2();
	}
	public void resetGame(){
		c_board.resetGame();
	}
	public void loadGame(){
		c_board.loadGame();
	}

	public void saveGame(){
		c_board.saveGame();
	}
	
	public CheckersControl() {
		setSkin(new CheckersControlSkin(this));
		
		
		c_board = new CheckersBoard();
		getChildren().addAll(c_board);
		
		chosenPiece = false;
		
		setOnMouseClicked(new EventHandler <MouseEvent> (){
		@Override
		public void handle (MouseEvent event){
					if(c_board.in_play()==true){
						if(chosenPiece==false){ 
							//Gets startX and startY
							startX=event.getX(); 
							startY=event.getY();
								
						if(c_board.getPiece((int)(startX/(getWidth()/8.0)), (int)(startY/(getHeight()/8.0))) == c_board.current_player()) {
							chosenPiece = true;
						}
						}
						else{
								//Gets endX and endY
							endX=event.getX();
							endY=event.getY();
			
							if(c_board.getPiece((int)(endX/(getWidth()/8.0)), (int)(endY/(getHeight()/8.0)))== 0) {
													
								// Code for handling jump chaining
								if(c_board.jumped()) {
									c_board.tryJump(startX,endX,startY,endY);
								}
								else if(c_board.makeJump()) {
									c_board.tryJump(startX,endX,startY,endY);
								}
								else {
									c_board.tryMove(startX,endX,startY,endY);
								}
							}
								chosenPiece = false;
						}
						}
			}
			
		});
		
		
		
	}
	
	// overridden version of the resize method
	@Override
	public void resize(double width, double height) {
		super.resize(width, height);
		c_board.resize(width, height);

	}
	
	// private fields of a reversi board
	CheckersBoard c_board;
	private boolean chosenPiece;
	private double startX, startY;
	private double endX , endY;
}

// class definition for a skin for the reversi control
// NOTE: to keep JavaFX happy we dont use the skin here
class CheckersControlSkin extends SkinBase<CheckersControl> {
	// default constructor for the class
	public CheckersControlSkin(CheckersControl rc) {
		super(rc);
	}
}

// class definition for the reversi board
class CheckersBoard extends Pane {
	// default constructor for the class
	public CheckersBoard() {
	//Allocating memory for arrays
		render = new CheckersPiece[8][8];
		horizontal = new Line [8];
		horizontal_t = new Translate [8];
		vertical = new Line[8];
		vertical_t = new Translate[8];	
		surrounding = new int[3][3];	
		makeJump = new boolean[8][8];

		initialiseLinesBackground();
		initialiseRender();
		resetGame();
	
	}

	
	
	// overridden version of the resize method to give the board the correct size
	@Override
	public void resize(double width, double height) {
		super.resize(width,height);
		
		// figure out the width and height of a cell
				cell_width = width / 8.0;
				cell_height = height / 8.0;
				
				// resize the rectangle to take the full size of the widget
				
				// set a new y on the horizontal lines and translate them into place
				horizontalResizeRelocate(width);
		     	verticalResizeRelocate(height);
				
				
				pieceResizeRelocate();

	}
	public void loadGame(){
		
		System.out.println("loading...");	
		
		try{  //Reading through character
			        FileReader h = new FileReader("Checkers.txt");
			        int character = h.read();
			        while (character != -1){
		         //   System.out.println(character);
			            character = h.read();
			        }
		 
			        //Close the stream
			    //    .close(); 
			        
		}
		catch(Exception e){
			System.err.println("Error: load failed " + e.getMessage());
		}
		System.out.println("Game Loaded");
		//- See more at: http://www.javabeat.net/java-filereader/#sthash.gbNOjCuh.dpuf
		//	 
			
		/*	 
			   	StringBuilder contents = new StringBuilder();
			    String line = null;
		      try {
		    	  FileReader h = new FileReader("Checkers.txt");
		    	  BufferedReader input =  new BufferedReader(h);
		        	
		             while (line != null){
		             
		            	 line = input.readLine();
		            	 contents.append(line).append(" ");
		            	 //  input.readLine())  contents.append(line);
		              //  contents.append();
		              }
		         
		      //   finally {
		       //      input.close();
		       //  }
		      //}
		    //  catch (IOException ex){
		    //    ex.printStackTrace();
		    //  }
		    //  System.out.println(contents.toString()); 
			   	 
		     	
		}
			
			catch(Exception e){
				System.err.println("Error: load failed " + e.getMessage());
			}
		return contents; */
		
		
	}
	public void saveGame(){

		// to view file open with notepad.
		
		try{
/*		 FileWriter fileWriter = new FileWriter(new File("c:/abc.txt"));
		    fileWriter.append("java2s.com");
		    fileWriter.close();
	*/	FileWriter saveFile = new FileWriter("Checkers.txt");
		BufferedWriter out; //= new BufferedWriter(saveFile);
			out = new BufferedWriter(saveFile);
		//	out.append();
			
			
			out.write("hello");
			for(int i = 0; i < render.length ; i++){
				 for(int j = 0 ; j < render.length; j ++){
			
		      out.write(" co-ords: " + i + " " +j + " "+ "Player: " +getPiece(i,j) + " ");
		 }
		 }
			 
			 out.write(" scores: " + "Red: " + player1_score + " "+" White: " + player2_score + " ");
		   	 out.flush();
		   	 System.out.println("Saving...");
			 out.close();
		   	 System.out.println("Game Saved");

			
		}
		
		catch(Exception e){
			System.err.println("Error: saved failed " + e.getMessage());
		}
		
		
		 
	}

	
	// public method for resetting the game
	public void resetGame() {
		System.out.println("Reset");
		
		resetRenders();
		render[0][0].setPiece(1);
		render[2][0].setPiece(1);
		render[4][0].setPiece(1);
		render[6][0].setPiece(1);
		render[1][1].setPiece(1);
		render[3][1].setPiece(1);
		render[5][1].setPiece(1);
		render[7][1].setPiece(1);
		render[0][2].setPiece(1);
		render[2][2].setPiece(1);
		render[4][2].setPiece(1);
		render[6][2].setPiece(1);
		
		render[1][5].setPiece(2);
		render[3][5].setPiece(2);
		render[5][5].setPiece(2);
		render[7][5].setPiece(2);
		render[0][6].setPiece(2);
		render[2][6].setPiece(2);
		render[4][6].setPiece(2);
		render[6][6].setPiece(2);
		render[1][7].setPiece(2);
		render[3][7].setPiece(2);
		render[5][7].setPiece(2);
		render[7][7].setPiece(2);
		
		for(int i=0;i<8;i++) {
				for(int j=0;j<8;j++){
					render[i][j].deThroned();
				}
		}
		
		
		in_play = true;	
		current_player = 2;
		opposing = 1;
		player1_score = 0;
		player2_score = 0;
	//	updateScores();
		
		

	}
	
	// private method that will reset the renders
	private void resetRenders() {
		
		for(int i = 0; i < 8; i++) {
			for(int j = 0; j < 8; j++) {
				render[i][j].setPiece(0);
		
			}		
		}
	}
	
	// private method that will initialise the background and the lines
	private void initialiseLinesBackground() {
		
		
		for(int j = 0; j< 8 ;j++){
		horizontal [j]= new Line(); horizontal_t [j]= new Translate(0,0);
		horizontal [j].getTransforms().add(horizontal_t[j]);
		getChildren().addAll(horizontal[j]);
		vertical [j]= new Line(); vertical_t [j]= new Translate(0,0);
		vertical[j].getTransforms().add(vertical_t[j]);
		getChildren().addAll(vertical[j]);
		
		
	
		}
	}
	
	// private method for resizing and relocating the horizontal lines
	private void horizontalResizeRelocate(final double width) {

			for(int j = 0; j < 8; j++) {
				horizontal_t[j].setY(j*cell_height);
				horizontal[j].setEndX(width);
			}			
	}
	
	// private method for resizing and relocating the vertical lines
	private void verticalResizeRelocate(final double height) {
	
			for(int j = 0; j < 8; j++) {
				vertical_t[j].setX(j*cell_width);
				vertical[j].setEndY(height);
			}		
	}
	
	// private method for swapping the players
	private void swapPlayers() {
			
		int swp = current_player;
		current_player = opposing;
		opposing = swp;

	}
	
	// private method for updating the player scores
	private void updateScores() {
		
		player1_score = 0;
		player2_score = 0;
		
		for(int i = 0; i < 8; i++) {
			for(int j = 0; j < 8; j++) {
				if(render[i][j].getPiece() == 1){
					player1_score ++;
				}
				if(render[i][j].getPiece()== 2){
					player2_score ++;
				}	
			}
		}

	}
	
	// private method for resizing and relocating all the pieces
	private void pieceResizeRelocate() {
				
		for(int i = 0; i < 8; i++) {
			for(int j = 0; j < 8; j++) {
				render[i][j].relocate(i * cell_width, j * cell_height);
				render[i][j].resize(cell_width, cell_height);	
				render[i][j].setBackground(i,j);
			}
		}

	}
	public int getPiece(final int x, final int y) {
		// If the x value or y value is out of range then return -1 otherwise return the board piece
				if(x < 0 || x >= 8 || y < 0 || y >= 8)
					return -1;
				else
					return render[x][y].getPiece();
		
			}
	
	//Method to check if a move is possible to make
		public void tryMove(double X1, double X2,double Y1,double Y2){
			// get a new cell width and cell height
			cell_width = getWidth() / 8.0;
			cell_height = getHeight() / 8.0;
	
			int x1 = (int) (X1 / cell_width); 
			int x2 = (int) (X2 / cell_width);
			int y1 = (int) (Y1 / cell_height);
			int y2 = (int) (Y2 / cell_height);
	
			if(!render[x1][y1].isCrowned()){ 
				// get offsets
				if((current_player==1 && x2-x1==1 && y2-y1==1)
						||(current_player==1 && x2-x1==-1 && y2-y1==1)
						||(current_player==2 && x2-x1==-1 && y2-y1==-1)
						||(current_player==2 && x2-x1==1 && y2-y1==-1)) {
					if(getPiece(x2,y2)==0 && getPiece(x1,y1)==current_player) {
						if(y2== 0 && getPiece(x1,y1) == 2 && render[x1][y1].isCrowned()==false) {
							render[x2][y2].crownMe();
	 					}
						else if(y2==7 && getPiece(x1,y1) ==1 && render[x1][y1].isCrowned()==false) {
							render[x2][y2].crownMe();
						}
						// set original place to piece 0 which is empty
						render[x1][y1].setPiece(0);
						// set new position to the current player
						render[x2][y2].setPiece(current_player);
						// swap the players
						swapPlayers();
	 				}
					// Else statement that allows a crowned piece to move in all 4 directions
							else
								if((x2-x1==1 && y2-y1==1)||(x2-x1==-1 && y2-y1==1)
								||(x2-x1==-1 && y2-y1==-1)||(x2-x1==1 && y2-y1==-1)) {
									if(getPiece(x2,y2)==0) {
										render[x2][y2].crownMe();
										render[x1][y1].setPiece(0);
										render[x2][y2].setPiece(current_player);
										swapPlayers();
									}
								}
					 	}
			}
			}
	//	Method to tryJump 
			public void tryJump(double X1, double X2,double Y1,double Y2){
				// get a new cell width and cell height
				cell_width = getWidth() / 8.0;
				cell_height = getHeight() / 8.0;
		
				boolean wasCrowned = false;
				int x1 = (int) (X1 / cell_width); 
				int x2 = (int) (X2 / cell_width);
				int y1 = (int) (Y1 / cell_height);
				int y2 = (int) (Y2 / cell_height);
		
				if(render[x1][y1].isCrowned()) {
					wasCrowned = true;
				}
				// math.abs to get absolute value
				if(Math.abs(x2-x1) == 2 && Math.abs(y2-y1) == 2){
					if(makeJump[x2][y2] == true) {
						if(wasCrowned) render[x2][y2].crownMe();
						else if(y2== 0 && getPiece(x1,y1) == 2) {
							render[x2][y2].crownMe();
						}
						else if(y2==7 && getPiece(x1,y1) ==1) {
							render[x2][y2].crownMe();
					}
						render[x1][y1].setPiece(0);
						render[x1+((x2-x1)/2)][y1+((y2-y1)/2)].setPiece(0);
						render[x2][y2].setPiece(current_player);
						updateScores();
						for(int i = 0; i < 8; i++) {
							for(int j = 0; j < 8; j++) {
								makeJump[i][j] = false;
				}
				}
				
						// if statements to check each condition.
										if(wasCrowned==false && render[x2][y2].isCrowned()==true) {
											out_of_play = true;
											swapPlayers();
										}
										// if no jump chain is available
										else if(!jumpChain(x2,y2)) {
											out_of_play = false;
											swapPlayers();
										}
										else {
											out_of_play = true;
										}
									}
								}
	}
			/* 
			+	   The logic of this method: this method will determine if a jump is possible on the board. If one is possible it
			+	   will return the square _to which_ a jump is possible. Attempt jump will lock you into selecting one of these squares
			+	   
			+	  */
	public boolean makeJump() {
					
	updateScores();
					
	boolean found = false;
		for(int i = 0; i < 8; i++) {
		for(int j = 0; j < 8; j++) {
			if(render[i][j].getPiece() == current_player) {
				if(!render[i][j].isCrowned()) {
					if(current_player==1 && getPiece(i+1,j+1)==opposing && getPiece(i+2,j+2)==0) {
							makeJump[i+2][j+2] = true;
								found = true;
					}
					else if(current_player==1 && getPiece(i-1,j+1)==opposing && getPiece(i-2,j+2)==0) {
							makeJump[i-2][j+2] = true;
								found = true;
					}
					else if(current_player==2 && getPiece(i-1,j-1)==opposing && getPiece(i-2,j-2)==0) {
							makeJump[i-2][j-2] = true;
								found = true;
					}
					else if(current_player==2 && getPiece(i+1,j-1)==opposing && getPiece(i+2,j-2)==0) {
							makeJump[i+2][j-2] = true;
								found = true;
					}
				}
			else {
				if(getPiece(i+1,j+1)==opposing && getPiece(i+2,j+2)==0) {
					makeJump[i+2][j+2] = true;
						found = true;
				}
				else if(getPiece(i-1,j+1)==opposing && getPiece(i-2,j+2)==0) {
					makeJump[i-2][j+2] = true;
						found = true;
				}
				else if(getPiece(i-1,j-1)==opposing && getPiece(i-2,j-2)==0) {
					makeJump[i-2][j-2] = true;
						found = true;
				}
				else if(getPiece(i+1,j-1)==opposing && getPiece(i+2,j-2)==0) {
					makeJump[i+2][j-2] = true;
						found = true;
				}
			}
		}
		}
		}
		return found;
						
	
	}
				// method for jump chaining
	public boolean jumpChain(int x, int y) {
		boolean found2 = false;
		int i = x;
		int j = y;
						
		if(!render[i][j].isCrowned()) {
			if(current_player==1 && getPiece(i+1,j+1)==opposing && getPiece(i+2,j+2)==0) {
						makeJump[i+2][j+2] = true;
							found2 = true;
			}
			else if(current_player==1 && getPiece(i-1,j+1)==opposing && getPiece(i-2,j+2)==0) {
						makeJump[i-2][j+2] = true;
							found2 = true;
			}
			else if(current_player==2 && getPiece(i-1,j-1)==opposing && getPiece(i-2,j-2)==0) {
						makeJump[i-2][j-2] = true;
							found2 = true;
			}
			else if(current_player==2 && getPiece(i+1,j-1)==opposing && getPiece(i+2,j-2)==0) {
						makeJump[i+2][j-2] = true;
							found2 = true;
			}
		}
		else {
		
			if(getPiece(i+1,j+1)==opposing && getPiece(i+2,j+2)==0) {
						makeJump[i+2][j+2] = true;
							found2 = true;
			}
			else if(getPiece(i-1,j+1)==opposing && getPiece(i-2,j+2)==0) {
						makeJump[i-2][j+2] = true;
							found2 = true;
			}
			else if(getPiece(i-1,j-1)==opposing && getPiece(i-2,j-2)==0) {
						makeJump[i-2][j-2] = true;
							found2 = true;
			}
			else if(getPiece(i+1,j-1)==opposing && getPiece(i+2,j-2)==0) {
						makeJump[i+2][j-2] = true;
							found2 = true;
			}
		}
				
		//System.out.println("Boolean found2 = "+found2);
				return found2;
 	}
	// private method that will determine if the end of the game has been reached
	private void determineEndGame() {
		// if the board has been filled or either player has lost their pieces then
		// we have reached the end of the game
		if(player1_score + player2_score == 24 || player1_score == 0 || player2_score == 0) {
			determineWinner();
		}
		
		// see if the current player can make a move if not see if the opposing player can make a move
		// if neither can make a move then we have reached end game
		if(makeJump()) {
			return;
		} else {
			swapPlayers();
			if(!makeJump())
				determineWinner();
		
		}	
	}
	public int score1() {
			return player1_score;
		}
	public int score2() {
			return player2_score;
		}
	public boolean canJump(int i, int j) {
		return makeJump[i][j];
		
	}
	public int current_player() {
		return current_player;
	}
	public int opposing() {
		return opposing;
	}
	
	public boolean in_play() {
		return in_play;
	}
	public boolean jumped(){
		return out_of_play;
	}
	
	// private method that determines who has won the game
	private void determineWinner() {
			if(player1_score > player2_score){
				System.out.println("Player 1 wins");
				System.out.println("Game has ended");
			}
			else{
				System.out.println("Player 2 wins");
 			System.out.println("Game has ended");
			}
	}

	// private method that will initialise everything in the render array
	private void initialiseRender() {
		

		render = new CheckersPiece[8][8];
		for(int i = 0; i < 8; i++)
		for(int j = 0; j < 8; j++) {
			render[i][j] = new CheckersPiece(0);
			getChildren().add(render[i][j]);
		}		
	}
	
	public void inPlay(boolean inplay){
				in_play = inplay;
			}
	
	// arrays for the lines that makeup the horizontal and vertical grid lines
	private Line[] horizontal;
	private Line[] vertical;
	// arrays holding translate objects for the horizontal and vertical grid lines
	private Translate[] horizontal_t;
	private Translate[] vertical_t;
	// arrays for the internal representation of the board and the pieces that are
	// in place
	private CheckersPiece[][] render;
	// the current player who is playing and who is his opposition
	private int current_player;
	private int opposing;
	//ellipse for crown
	private Ellipse crown;
	// is the game currently in play
	private boolean in_play;
	private boolean out_of_play;
	// current scores of player 1 and player 2
	private int player1_score;
	private int player2_score;
	// the width and height of a cell in the board
	private double cell_width;
	private double cell_height;
	// 3x3 array that holds the pieces that surround a given piece
	private int[][] surrounding;
	private boolean[][] makeJump;
}

// class definition for a reversi piece
class CheckersPiece extends Group {
	
	// default constructor for the class
	public CheckersPiece(int player) {
	
		this.player = player;
		t = new Translate();
		
		background = new Rectangle(); 
		background.getTransforms().add(t);
		
		piece = new Ellipse();
		piece.getTransforms().add(t);
		
		crown = new Ellipse();
		crown.getTransforms().add(t);

		
		// choose which piece type we have
		if(player == 1) {	
			
			piece.setFill(Color.WHITE);
			piece.setVisible(true);
			
		}
		
		else if (player == 2) {
			
			piece.setFill(Color.RED);
			piece.setVisible(true);
		
			}
		
		else{
			
			piece.setVisible(false);
		}
		getChildren().addAll(background,piece,crown);
	}
	

	// overridden version of the resize method to give the piece the correct size
	@Override
	public void resize(double width, double height) {
		// call the super class method
		super.resize(width, height);
			
				// update depending on the type
		// re-center the ellipse// and update the radius
		piece.setCenterX(width / 2); piece.setCenterY(height / 2);
		piece.setRadiusX(width / 2); piece.setRadiusY(height / 2);
		
		//King ellipse resize and relocate
		crown.setCenterX(width / 2); crown.setCenterY(height / 2);
		crown.setRadiusX(width / 4.5); crown.setRadiusY(height / 4.5);
		
		background.setWidth(width);background.setHeight(height);
	

	}
	
	// overridden version of the relocate method to position the piece correctly
	@Override
	public void relocate(double x, double y) {
	
		super.relocate(x,y);
		t.setX(x); t.setY(y);

	}
	
	// public method that will swap the colour and type of this piece
	public void swapPiece() {
		
		if(getPiece() == 1 ){
			setPiece(2) ;
		}
		else if(getPiece() == 2){
			setPiece(1);
		}
		else{
			piece.setVisible(false);
		}
	}
	
	// method that will set the piece type
	public void setPiece(final int type) {
		
		player = type;
		
		//This if statement set up the pieces once they are crowned
			if (isCrowned() == true){
					if(player == 1) {
						piece.setFill(Color.IVORY);
						piece.setVisible(true);
						
						crown.setFill(Color.DARKRED);
						crown.setVisible(true);
		
			}
			else if (player == 2) {
				piece.setFill(Color.DARKRED);
				piece.setVisible(true);
										
				crown.setFill(Color.IVORY);
				crown.setVisible(true);
			}				
		
			else{
				piece.setVisible(false);
				crown.setVisible(false);
			}
			}
			
			else{
				crown.setVisible(false);
						if(player == 1) {
							piece.setFill(Color.IVORY);
							piece.setVisible(true);
							}
						
							else if (player == 2) {
								piece.setFill(Color.DARKRED);
								piece.setVisible(true);
						
							}
							else {
								piece.setVisible(false);			
							}
			}	
	}
	 public void setBackground(int i, int j){
		
		//Sets up the alternating squares on the checkers board				
		 			if(i%2==0 && j%2==0){
		 				background.setFill(Color.BLACK);
		 			}
		 			else if(i%2==0 && j%2!=0){
		 			background.setFill(Color.BLANCHEDALMOND);
				}
		 			else if(i%2!=0 && j % 2!=0){
					background.setFill(Color.BLACK);
				}
		 			else if (i %2!=0 && j%2==0){
					background.setFill(Color.BLANCHEDALMOND);
		 		}		
			
			
	 }
	// returns the type of this piece
	public int getPiece() {
		// NOTE: this is to keep the compiler happy until you get to this point
		return player;
	}
	public void crownMe(){
		isCrowned = true;
	}
	public boolean isCrowned(){
		return isCrowned;
	}
	public void setCrown (boolean value){
		isCrowned = value;
	}
	//Had a bug when resetting the game the formelry kinged pieces were not reset.
	//I changed the value of isCrowned to false so I can reset all the pieces
	public void deThroned (){
		isCrowned = false;
	}
	// private fields
	private int player;		// the player that this piece belongs to
	private Ellipse crown;
	private Ellipse piece;	// ellipse representing the player's piece
	private Rectangle background; // rectangle that makes the background of the board
	private boolean isCrowned;
	private Translate t;	// translation for the player piece
}
